# 🏃 Java Stream Performance Test

## 🙅‍♂️ Java Stream에서 자주 하는 실수 7가지
1. collect(), forEach(), reduce() 등과 같은 Terminal Operation을 쓰지 않는 경우가 있다..
2. 데이터 구조를 바꿀 때 예상치 못한 결과가 나올 수도 있다.
3. 병렬로 처리하는 것이 항상 성능 향상에 좋은 것은 아니다. (작은 프로젝트에서는 성능을 떨어뜨릴 수도 있다.)
4. filter()나 map() 같은 중간 연산자들을 너무 많이 주렁주렁 연결하면 성능 저하(오버헤드) 가 발생할 수 있다.
5. findFirst()나 reduce() 같은 연산은 결과로 Optional 객체를 반환하는데, 이를 제대로 처리하지 않는 것이다
6. 병렬 스트림을 사용할 때 공유 변수를 동시에 바꾸면 race condition이 발생하거나 결과값이 뒤죽박죽이 될 수 있다.
7. 새로운 스트림을 리턴하는 중간 연산(Intermediate)과, 실제로 결과를 도출해 내는 최종 연산(Terminal)의 차이를 혼동하는 것이다.

## 소개
실행 속도에 영향을 주는 3,4번 실수를 구현 해 볼 것이다.

### 1. 큰 데이터와 작은 데이터에서 순차처리와 병렬처리의 실행 속도 비교(StreamLab.java)
1. **데이터 크기**: 작은 데이터: 1,000개, 큰 데이터: 10,000,000개
2. **연산 작업**: 리스트의 각 숫자를 제곱하여 다시 리스트에 넣기

### 결과 분석 (Result)

| 데이터 크기 | 처리 방식 (Method) | 소요 시간 (측정마다 다르게 나옴) | 비고 |
|:---:|:---:|:---:|:---|
| **작은 데이터** | **Stream (Sequential)** | 1ms | 작은 데이터에서는 순차가 더 빠르게 실행됨|
|  | **Stream (Parallel)** | 12ms | 데이터가 적을 땐 병렬 처리가 스레드 생성 비용 때문에 더 느림 |
| **큰 데이터** | **Stream (Sequential)** | 445ms | 데이터가 클 때에는 순차가 더 느리게 실행됨 |
| | **Stream (Parallel)** | 336ms | 데이터가 클 때에는 병렬처리가 더 빠름 |

### 2. filter()나 map() 같은 중간 연산자들을 많이 사용했을 때의 성능 비교 (StreamLab2.java)

### 결과 분석 (Result)

| 처리 방식 (Method) | 소요 시간 (측정마다 다르게 나옴) | 비고 |
|:---:|:---:|:---|
| **중간 연산자가 많을 때** | 17ms | 중간 연산자가 많을 때 속도가 더 느림 |
| **작은 데이터**  | 2ms | 중간 연산자가 적을 때 속도가 더 빠름 |
